<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Console Init
global.ReusableMetadataMap = ds_map_create();
global.Console = id;

//Console enums
enum ConsoleMetadata
{
  ParamCount,
  Description,
  Parameters,
  ParameterTypes,
  SuggestionListBuilder
}

enum ConsoleParamType
{
  Description,
  DefaultSuggestionBuilder
}

//Customize these according to your own naming preferences:
m_scriptSuffix = "_scr";
m_scriptPrefix = "";

m_errorList = ds_list_create();
m_warningList = ds_list_create();
m_consoleContent = ds_list_create();
m_consoleDrawContent = ds_list_create();
m_bufferDraw = true;
m_bufferDrawLast = false;
m_consoleHistory = ds_list_create();
depth = -100000;
m_commandString = "";
m_intelliBgWidth = 0;
m_intelliThresh = 1;
m_intelliModeGuide = false;
m_intelliGuideBufferRequired = false;
m_intelliGuideHlCol = c_lime;
m_intelliGuideCommand = undefined;
m_intelliGuideInfo = undefined;
m_intelliGuideInfo1 = undefined;
m_intelliGuideInfoHl = undefined;
m_intelliGuideInfo2 = undefined;
m_intelliList = ds_list_create();
m_intelliInfoList = ds_list_create();
m_intelliIndex = -1;
m_intelliBgColor = c_dkgray;
m_intelliBgHlColor = c_gray;
m_suggestionList = ds_list_create();
m_suggestionDisplayList = ds_list_create();
m_suggestionDrawX = 100;
m_suggestionDrawWidth = 200;
m_suggestionIndex = -1;
m_suggestionMarginX = 4;
m_width = 200;
m_height = 100;
m_historyIndex = -1;
m_caretPos = 0;
m_caretPosX = 0;
m_caretPosY = 0;
m_active = false;
m_xPos = undefined;
m_yPos = undefined;
m_relPosX = .02;
m_relPosY = .33;
m_relWidth = .4;
m_relHeight = .32;
m_keySuppress = false;
m_lastKey = -1;
m_activationKey = 192;
m_bgColor = c_black;
m_textColor = c_white;
m_drawBufferX = 14;
m_drawBufferY = 6

m_shiftMap = InitKbdShiftMap_scr();
m_knownKeysMap = InitKbdKnownKeys_scr();
var arr = InitConsoleCommands_scr();
m_commandList = arr[0];
m_commandNameList = arr[1];
m_commandMap = arr[2];
m_metadataMap = arr[3];
m_validatorMap = arr[4];
m_valMetadataMap = arr[5];
m_valDisplayMap = arr[6];
m_validTypes = arr[7];
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Positioning

if(!is_undefined(m_relPosX))
{
  x = m_relPosX * view_wview;
}

if(!is_undefined(m_relPosY))
{
  y = m_relPosY * view_hview;
}

if(!is_undefined(m_relWidth))
{
  m_width = view_wview * m_relWidth;
}

if(!is_undefined(m_relHeight))
{
  m_height = view_hview * m_relHeight;
}

m_x1 = x;
m_y1 = y - m_height;
m_x2 = x + m_width;
m_y2 = y;

//Position Caret
var len = string_length(m_commandString);

var str = string_delete(m_commandString, m_caretPos + 1, len);
m_caretPosX = string_width(str);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Buffer draw list
var line, width;
if(m_bufferDrawLast)
{
  m_bufferDrawLast = false;
  //Get the last line in the console content list
  var lastIndex = ds_list_size(m_consoleContent) - 1;
  line = m_consoleContent[| lastIndex];
  width = string_width(line);
  if(width &gt;= m_width)
  {
    //This line will hang over the console box; it needs to be broken-up
    var wordsArr = split(line, " ");
    var lineTemp = "";
    for(var n = 0; n &lt; array_length_1d(wordsArr); n++)
    {
      if(string_width(lineTemp + " " + wordsArr[n]) &lt; m_width)
      {
        if(lineTemp != "")
        {
          lineTemp += " ";
        }
        lineTemp += wordsArr[n];
      }
      else
      {
        ds_list_add(m_consoleDrawContent, lineTemp);
        lineTemp = "";
        n--;
      } 
    }
    
    if(lineTemp != "")
    {
      ds_list_add(m_consoleDrawContent, lineTemp);
    }
  }
  else
  {
    ds_list_add(m_consoleDrawContent, line); 
  }
}

if(m_bufferDraw)
{
  ds_list_clear(m_consoleDrawContent);
  m_bufferDraw = false;
  for(var i = 0; i &lt; ds_list_size(m_consoleContent); i++)
  {
    line = m_consoleContent[| i];
    width = string_width(line);
    if(width &gt;= m_width)
    {
      //This line will hang over the console box; it needs to be broken-up
      var wordsArr = split(line, " ");
      var lineTemp = "";
      for(var n = 0; n &lt; array_length_1d(wordsArr); n++)
      {
        if(string_width(lineTemp + " " + wordsArr[n]) &lt; m_width)
        {
          if(lineTemp != "")
          {
            lineTemp += " ";
          }
          lineTemp += wordsArr[n];
        }
        else
        {
          if(lineTemp == "")
          {
            //ToDo: Add in logic to split up a long line with no spaces
          }
          ds_list_add(m_consoleDrawContent, lineTemp);
          lineTemp = "";
          n--;
        } 
      }
      
      if(lineTemp != "")
      {
        ds_list_add(m_consoleDrawContent, lineTemp);
      }
    }
    else
    {
      ds_list_add(m_consoleDrawContent, line); 
    } 
  }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Buffer Intellisense Guide

//Get the current parameters
if(m_intelliModeGuide)
{
  if(m_intelliGuideBufferRequired)
  {
    m_intelliGuideBufferRequired = false;
    //Get the width of the intelli background
    m_intelliBgWidth = m_width;
    var intelliBgWidth = string_width(m_intelliGuideCommand + m_intelliGuideInfo);
    if(m_width &lt; intelliBgWidth)
    {
      m_intelliBgWidth = intelliBgWidth;
    }
    
    var cmdArr = split(m_commandString, "(");
    
    if(array_length_1d(cmdArr) &gt; 1)
    {
      var paramArr = split(cmdArr[1], ")"); 
      var currentParams = paramArr[0];
      var commaArr = split(currentParams, ",");
      var commaCount = array_length_1d(commaArr) - 1;
      
      //Get the guide parameters
      var guideParamArr = split(m_intelliGuideInfo, ")");
      var len = array_length_1d(guideParamArr)
      if(len &gt; 1 &amp;&amp; string_pos(")", m_commandString) == 0)
      {
        var guideParams = guideParamArr[0];
        //Remove leading '('
        guideParams = string_delete(guideParams, 1, 1);
        var arr = split(guideParams, ",");
        if(commaCount &lt; array_length_1d(arr))
        {
          var paramTypeArr = split(arr[commaCount], " ");
          GetSuggestionList_scr(m_commandString, commaCount, paramTypeArr[0]);      
        }
        
        var infoPt1 = "(";
        var infoPt2 = "";
        var pt1 = true;
        m_intelliGuideInfoHl = "";
        for(var i = 0; i &lt; array_length_1d(arr); i++)
        {
          if(i == commaCount)
          {
            m_intelliGuideInfoHl = arr[i];
            pt1 = false;
            if(i &lt; array_length_1d(arr) - 1) infoPt2 += ",";
          }
          else if(pt1)
          {
            infoPt1 += arr[i];
            if(i &lt; array_length_1d(arr) - 1)
            {
              infoPt1 += ",";
            }
          }
          else
          {
            infoPt2 += arr[i];
            if(i &lt; array_length_1d(arr) - 1)
            {
              infoPt2 += ",";
            }
          }
        }
        infoPt2 += ")";
        //Add the description back in
        if(array_length_1d(guideParamArr) &gt; 1)
        {
          infoPt2 += guideParamArr[1];
        }
        m_intelliGuideInfo1 = infoPt1;
        m_intelliGuideInfo2 = infoPt2;
      }
      else
      {
        m_intelliGuideInfo1 = m_intelliGuideInfo;
        m_intelliGuideInfoHl = "";
        m_intelliGuideInfo2 = "";
      }
    }
  }
}
else
{
  m_intelliBgWidth = m_width;
  var thisWidth;
  //Get intellisense background width
  for(var i = 0; i &lt; ds_list_size(m_intelliList); i++)
  {
    thisWidth = string_width(m_intelliList[|i ] + 
      m_intelliInfoList[| i]) + m_drawBufferX;
    
    if(thisWidth &gt; m_intelliBgWidth)
    {
      m_intelliBgWidth = thisWidth;
    }
  }
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Check for console activation

if(keyboard_check_pressed(m_activationKey))
{
  m_active = !m_active
  if(m_active)
  {
    m_lastKey = keyboard_key;
    m_keySuppress = true;
  }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Handle typing

if(m_active)
{
  if(keyboard_check_pressed(vk_enter))
  {
    ParseConsoleCommand_scr(m_commandString);  
    m_commandString = "";
    m_caretPos = 0;
    m_bufferDrawLast = true;
    //Reset Intellisense
    ds_list_clear(m_intelliList);
    ds_list_clear(m_intelliInfoList);
    m_intelliIndex = -1;
    m_intelliModeGuide = false;
  }
  else if(keyboard_check(vk_backspace))
  {
    var len = string_length(m_commandString);
    if(len &gt; 0)
    {
      m_commandString = string_delete(m_commandString, m_caretPos, 1);
      m_caretPos--;
      if(m_intelliModeGuide)
      {
        //Check if we're still in guide mode
        if(string_pos(m_intelliGuideCommand + "(", m_commandString) != 1)
        {
          m_intelliModeGuide = false;
          //BuildIntellisenseList_scr(m_commandString);
        }
      }
      BuildIntellisenseList_scr(m_commandString);
      m_intelliGuideBufferRequired = true;
    }
    else
    {
      ds_list_clear(m_intelliList);
      ds_list_clear(m_intelliInfoList);
      m_intelliIndex = -1;
    }
  }
  else if(keyboard_check(vk_left))
  {
    if(m_caretPos &gt; -1)
    {
      m_caretPos--;
    }
  }
  else if(keyboard_check(vk_right))
  {
    var len = string_length(m_commandString);
    if(m_caretPos &lt; (len))
    {
      m_caretPos++;
    }
  }
  else if(keyboard_check_pressed(vk_up))
  {
    if(m_intelliModeGuide)
    {
      var suggSize = ds_list_size(m_suggestionList);
      if(suggSize &gt; 0 &amp;&amp; m_suggestionIndex &gt;= 0)
      {
        m_suggestionIndex -= 1;
      }
    }
    else
    {
      var intelliSize = ds_list_size(m_intelliList);
      if(intelliSize &gt; 0 &amp;&amp; m_intelliIndex &gt;= 0)
      {
        m_intelliIndex -= 1;
      }
      else if(m_historyIndex == -1 &amp;&amp; ds_list_size(m_consoleHistory) &gt; 0)
      {
        //Go to the last entry in the console history
        m_historyIndex = ds_list_size(m_consoleHistory) - 1;
        m_commandString = m_consoleHistory[| m_historyIndex];
        m_caretPos = string_length(m_commandString);
      }
      else if(m_historyIndex &gt; 0)
      {
        m_historyIndex--;
        m_commandString = m_consoleHistory[| m_historyIndex];
        m_caretPos = string_length(m_commandString);
      }
    }
  }
  else if(keyboard_check_pressed(vk_down))
  {
    if(m_intelliModeGuide)
    {
      var suggSize = ds_list_size(m_suggestionList);
      if(suggSize &gt; 0 &amp;&amp; m_suggestionIndex &lt; suggSize - 1)
      {
        m_suggestionIndex += 1;
      }
    }
    else
    {
      var intelliSize = ds_list_size(m_intelliList);
      if(intelliSize &gt; 0 &amp;&amp; m_intelliIndex &lt; intelliSize)
      {
        m_intelliIndex += 1;
      }
      else if(m_historyIndex != -1 &amp;&amp; m_historyIndex &lt; (ds_list_size(m_consoleHistory) - 1))
      {
        m_historyIndex++;
        m_commandString = m_consoleHistory[| m_historyIndex];
        m_caretPos = string_length(m_commandString);
      }
    }
  }
  else if(keyboard_check_pressed(vk_tab))
  {
    //Autocomplete intellisense
    if(m_intelliModeGuide)
    {
      if(!is_undefined(m_suggestionList) &amp;&amp; ds_list_size(m_suggestionList) &gt; 0)
      {
        if(m_suggestionIndex == -1) m_suggestionIndex = 0;
        var suggestion = m_suggestionList[| m_suggestionIndex];
        var pos = string_pos("(", m_commandString);
        var len = string_length(m_commandString);
        var cmd = string_delete(m_commandString, pos + 1, len);
        var args = string_delete(m_commandString, 1, pos + 1);
        var argsArr = split(args, ",");
        var argNumber = array_length_1d(argsArr);
        var maxIndex = argNumber - 1;
        argsArr[maxIndex] = suggestion;
        for(var i = 0; i &lt; argNumber; i++)
        {
          cmd += argsArr[i];
          if(i &lt; argNumber - 1)
          {
            cmd += ",";
          }   
        }
        m_commandString = cmd;
        m_caretPos = string_length(m_commandString);
        if(!is_undefined(m_suggestionList))
        {
          ds_list_clear(m_suggestionList);
        }
        m_suggestionIndex = -1;
      }
    }
    else
    {
      if(ds_list_size(m_intelliList) &gt; 0) 
      {
        if(m_intelliIndex == -1) m_intelliIndex = 0;
        m_commandString = m_intelliList[| m_intelliIndex];
        var info = m_intelliInfoList[| m_intelliIndex];
        if(string_pos("()", info) == 1)
        {
          //This is a parameterless command - add in the parens for ease
          m_commandString += "()";
        }
        else
        {
          m_commandString += "(";
        }
        m_caretPos = string_length(m_commandString);
      }
    }
  }
  else
  {
    if(keyboard_key != m_lastKey)
    {
      m_keySuppress = false;
    }
    m_lastKey = keyboard_key;
    
    if(!m_keySuppress)
    {
      if(keyboard_key != 0)
      {
        var attempt = m_knownKeysMap[? keyboard_key];
        var char;
        if(!is_undefined(attempt))
        {
          if(string_length(attempt) == 1)
          {
            char = attempt;
          }
          else
          {
            char = "";
          }
        }
        else
        {
          char = chr(keyboard_key);
        }
        
        if(keyboard_key &gt;= 65 &amp;&amp; keyboard_key &lt;= 90)
        {
          if(!keyboard_check(vk_shift))
          {
            char = string_lower(char);
          } 
        }
        else
        {
          var attempt = m_knownKeysMap[? char];
          if(!is_undefined(attempt))
          {
            char = attempt;
          }
            
          if(keyboard_check(vk_shift))
          {
            var attempt = m_shiftMap[? char];
            if(!is_undefined(attempt))
            {
              char = attempt;
            }
            
            if(char == ")")
            {
              //Clear suggestion lists
              ds_list_clear(m_suggestionList);
              ds_list_clear(m_suggestionDisplayList);
            }
          }  
        }
        
        m_commandString += char;
        m_caretPos++;
        m_keySuppress = true;
        m_intelliGuideBufferRequired = true;
        if(string_length(m_commandString) &gt;= m_intelliThresh &amp;&amp; char != "")
        {
          if(ds_list_size(m_intelliList) == 0)
          {
            BuildIntellisenseList_scr(m_commandString);
            var test = m_intelliList;
            var test2 = "test";
          }
          else if(!m_intelliModeGuide)
          {
            //Check to see if we should be going to guide mode
            if(m_intelliIndex != -1 &amp;&amp; m_intelliIndex &lt; ds_list_size(m_intelliList))
            {
              var intelliCommand = m_intelliList[| m_intelliIndex];
              if(string_pos(intelliCommand + "(", m_commandString) == 1)
              {
                m_intelliModeGuide = true;
                m_intelliGuideCommand = m_intelliList[| m_intelliIndex];
                if(is_undefined(m_intelliGuideCommand))
                {
                  m_intelliGuideCommand = "Error: intellisense command was undefined. ";
                }
                m_intelliGuideInfo = m_intelliInfoList[| m_intelliIndex];
                if(is_undefined(m_intelliGuideInfo))
                {
                  m_intelliGuideInfo = "Error: intellisense info was undefined";
                }
                m_intelliIndex = -1;
              }
            }
            
            UpdateIntellisenseList_scr(m_commandString);
          }
        }
      }  
      else
      {
        m_keySuppress = false;
      }
    }  
  }
}
else
{
  m_keySuppress = false;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw console text

if(m_active)
{
  draw_set_halign(fa_left);
  //Draw console background
  draw_rectangle_colour(m_x1 - m_drawBufferX, m_y1, m_x2, 
    m_y2 + m_drawBufferY, m_bgColor, m_bgColor, m_bgColor, m_bgColor, false);

  draw_set_font(console_fnt);
  draw_set_valign(fa_bottom);
  var h = string_height("A") + 2;
  var pos = x + m_caretPosX;
  draw_line_colour(pos, y, pos, y - h, m_textColor, m_textColor);
  draw_text_colour(x - 10, y, "&gt;", 
    m_textColor, m_textColor, m_textColor, m_textColor, 1);
  draw_text_colour(x, y, m_commandString, 
    m_textColor, m_textColor, m_textColor, m_textColor, 1);
  
  var maxIndex = ds_list_size(m_consoleDrawContent) - 1;
  var yy = y;
  for(var i = maxIndex; i &gt; -1; i--)
  {
    yy -= h;
    draw_text_colour(x, yy, m_consoleDrawContent[| i], 
      m_textColor, m_textColor, m_textColor, m_textColor, 1);
  }
  
  //Draw intellisense
  if(!m_intelliModeGuide)
  {
    var count = ds_list_size(m_intelliList);
    if(count != 0)
    {
      //Draw background
      draw_rectangle_colour(m_x1 - m_drawBufferX, m_y2 + m_drawBufferY, 
        x + m_intelliBgWidth, m_y2 + m_drawBufferY + count*h, m_intelliBgColor,
        m_intelliBgColor, m_intelliBgColor, m_intelliBgColor, false);   
      
      //Draw background highlight
      if(m_intelliIndex &gt;= 0)
      {
        var hlDrawX1 = m_x1 - m_drawBufferX;
        var hlDrawY1 = m_y2 + m_drawBufferY + h * m_intelliIndex;
        var hlDrawX2 = x + m_intelliBgWidth;
        var hlDrawY2 = hlDrawY1 + h;
        draw_rectangle_colour(hlDrawX1, hlDrawY1, hlDrawX2, hlDrawY2,
          m_intelliBgHlColor, m_intelliBgHlColor, m_intelliBgHlColor, 
          m_intelliBgHlColor, false); 
      }
      yy = y + m_drawBufferY;
      for(var i = 0; i &lt; count; i++)
      {
        yy += h;
        var text = m_intelliList[| i] + m_intelliInfoList[| i];
        draw_text_colour(x, yy, text, 
          m_textColor, m_textColor, m_textColor, m_textColor, 1);
      }
    }
  }
  else
  {
    //Draw the guide
    draw_rectangle_colour(m_x1 - m_drawBufferX, m_y2 + m_drawBufferY, 
      x + m_intelliBgWidth, m_y2 + m_drawBufferY + h, m_intelliBgColor, 
      m_intelliBgColor, m_intelliBgColor, m_intelliBgColor, false);
    yy = y + m_drawBufferY + h;
    //Draw first part
    draw_text_colour(x, yy, m_intelliGuideCommand + m_intelliGuideInfo1, 
      m_textColor, m_textColor, m_textColor, m_textColor, 1);
    var shiftX = string_width(m_intelliGuideCommand + m_intelliGuideInfo1);
    var shiftXHl = shiftX;
    //Draw highlight param
    var hlText = m_intelliGuideInfoHl;
    draw_text_colour(x + shiftX, yy, m_intelliGuideInfoHl, m_intelliGuideHlCol,
      m_intelliGuideHlCol, m_intelliGuideHlCol, m_intelliGuideHlCol, 1);
    shiftX = shiftX + string_width(m_intelliGuideInfoHl);
    //Draw the rest
    draw_text_colour(x + shiftX, yy, m_intelliGuideInfo2, m_textColor, 
    m_textColor, m_textColor, m_textColor, 1);
    
    if(!is_undefined(m_suggestionList))
    {
      var suggCount = ds_list_size(m_suggestionList);
      if(suggCount &gt; 0)
      {
        //Draw Suggestion background
        var suggDrawY1 = m_y2 + m_drawBufferY*2 + h;
        var suggDrawY2 = suggDrawY1 + suggCount*h;
        var x1 = x + shiftXHl;
        var x2 = x1 + m_suggestionDrawWidth + m_drawBufferX*2
        draw_rectangle_colour(x1 - m_drawBufferX, suggDrawY1, x2, suggDrawY2, 
          m_intelliBgColor, m_intelliBgColor, m_intelliBgColor, m_intelliBgColor, false);
        //Draw highlighted suggestion
        if(m_suggestionIndex &gt;= 0)
        {
          draw_rectangle_colour(x1 - m_drawBufferX, suggDrawY1 + m_suggestionIndex*h,
            x2, suggDrawY1 + m_suggestionIndex*h + h, m_intelliBgHlColor,
            m_intelliBgHlColor, m_intelliBgHlColor, m_intelliBgHlColor, false);
        }
        yy = suggDrawY1;
        for(var i = 0; i &lt; suggCount; i++)
        {
          yy += h;
          var text = m_suggestionList[| i];
          draw_text_colour(x1, yy, text, m_textColor,
            m_textColor, m_textColor, m_textColor, 1);
        }
      }
    }
  }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
